# common_logic/backtesting_services/backtrader_runner.py
"""
This module provides functions to run backtests using the Backtrader library.
It includes:
- Robust pathing setup for project-wide imports.
- A custom PandasDataFeed for mapping CSV columns.
- Dynamic loading of strategy classes from files.
- A core `run_backtest` function to execute strategies and extract metrics.
- A command-line interface for running backtests directly.
"""

import sys
from pathlib import Path
import importlib.util
import os
import logging
import json
import argparse
from typing import Dict, Any, Type
import pandas as pd
import backtrader as bt

# --- Robust Pathing Setup ---
# Ensures that modules from the project root (e.g., 'agents') can be imported.
SCRIPT_DIR = Path(__file__).resolve().parent
PROJECT_ROOT = SCRIPT_DIR.parent.parent
if str(PROJECT_ROOT) not in sys.path:
    sys.path.insert(0, str(PROJECT_ROOT))
# --- End Pathing Setup ---

# Attempt to import utility functions; handle if not found.
try:
    from agents.utils.timeframe_utils import parse_timeframe_string
    from agents.utils.chart_util import plot_strategy_behavior
except ImportError:
    # Log a warning if utility functions are not found, as they might be optional
    # or specific to certain functionalities not always used by this runner.
    logging.warning("Could not import timeframe_utils or chart_util from agents.utils. Plotting may be affected.")
    parse_timeframe_string = None # Define as None to allow conditional usage
    plot_strategy_behavior = None # Define as None


# --- Logger Configuration ---
# It's good practice to configure the logger at the module level if it's used across functions.
# However, if this script is also run as __main__, the __main__ block's logging config will take precedence for that execution.
logger = logging.getLogger(__name__) # Get a logger specific to this module


class PandasDataFeed(bt.feeds.PandasData):
    """
    Custom Backtrader data feed for Pandas DataFrames.
    Maps standard CSV column names (Open, High, Low, Close, Volume) to Backtrader's expected lines.
    The DataFrame index is assumed to be the datetime.
    """
    lines = ('open', 'high', 'low', 'close', 'volume')
    params = (
        ('datetime', None),  # Use the DataFrame index for datetime
        ('open', 'Open'),    # Map 'Open' column in DataFrame to 'open' line
        ('high', 'High'),
        ('low', 'Low'),
        ('close', 'Close'),
        ('volume', 'Volume'),
        ('openinterest', -1) # -1 indicates no 'openinterest' column is expected or used
    )

def load_strategy_class_from_file(strategy_file_path: str, strategy_class_name: str) -> Type[bt.Strategy]:
    """
    Dynamically loads a strategy class from a specified Python file.

    This function is crucial for allowing the system to use strategy definitions
    that are not known at compile time (e.g., generated by an LLM or selected by a user).
    It creates a unique module name for each loaded file to prevent caching issues if the
    same file path is loaded multiple times with different content within the same Python session.

    Args:
        strategy_file_path (str): The absolute or relative path to the Python file
                                  containing the strategy class definition.
        strategy_class_name (str): The name of the strategy class to be loaded
                                   from the file (e.g., "MyAwesomeStrategy").

    Returns:
        Type[bt.Strategy]: The loaded strategy class object, ready to be instantiated.

    Raises:
        FileNotFoundError: If the `strategy_file_path` does not exist.
        ImportError: If the Python file cannot be imported as a module (e.g., due to syntax errors
                     or if the `spec.loader` is None).
        AttributeError: If the specified `strategy_class_name` does not exist as an attribute
                        (e.g., class, function) within the loaded module.
    """
    if not os.path.exists(strategy_file_path):
        logger.error(f"Strategy file not found at path: {strategy_file_path}")
        raise FileNotFoundError(f"Strategy file not found: {strategy_file_path}")

    # Create a unique module name to avoid import caching issues if the file is reloaded
    # (e.g., if the content of the strategy file changes between runs).
    module_name = f"strategy_module_{Path(strategy_file_path).stem}_{pd.Timestamp.now().strftime('%Y%m%d%H%M%S%f')}"

    spec = importlib.util.spec_from_file_location(module_name, strategy_file_path)
    if spec is None or spec.loader is None:
        logger.error(f"Could not create module spec or loader for: {strategy_file_path}")
        raise ImportError(f"Could not load module spec from {strategy_file_path}")

    strategy_module = importlib.util.module_from_spec(spec)
    # Add to sys.modules BEFORE execution to allow for relative imports within the loaded module, if any.
    sys.modules[module_name] = strategy_module
    try:
        spec.loader.exec_module(strategy_module)
    except Exception as e:
        # If execution fails, remove the partially loaded module from sys.modules.
        if module_name in sys.modules:
            del sys.modules[module_name]
        logger.error(f"Failed to execute strategy module {strategy_file_path}: {e}", exc_info=True)
        raise ImportError(f"Error executing strategy module {strategy_file_path}: {e}") from e


    if not hasattr(strategy_module, strategy_class_name):
        logger.error(f"Strategy class '{strategy_class_name}' not found in {strategy_file_path}.")
        # Clean up the loaded module if the class isn't found.
        if module_name in sys.modules:
            del sys.modules[module_name]
        raise AttributeError(f"Strategy class '{strategy_class_name}' not found in module {strategy_file_path}")

    logger.info(f"Successfully loaded strategy class '{strategy_class_name}' from '{strategy_file_path}'.")
    return getattr(strategy_module, strategy_class_name)

def run_backtest(
    strategy_file_path: str,
    data_file_path: str,
    strategy_class_name: str,
    initial_cash: float = 100000.0,
    commission_pct: float = 0.001,
    **strategy_kwargs: Any
) -> Dict[str, Any]:
    """
    Runs a Backtrader backtest for a given strategy, data, and parameters.

    Args:
        strategy_file_path (str): Path to the Python file containing the strategy class.
        data_file_path (str): Path to the CSV data file.
        strategy_class_name (str): Name of the strategy class within the strategy file.
        initial_cash (float): Starting cash for the backtest. Defaults to 100,000.0.
        commission_pct (float): Commission percentage per trade (e.g., 0.001 for 0.1%).
                                Defaults to 0.001.
        **strategy_kwargs (Any): Additional keyword arguments to be passed as parameters
                                 to the strategy's __init__ method.

    Returns:
        Dict[str, Any]: A dictionary containing various performance metrics from the backtest,
                        including status, final portfolio value, Sharpe ratio, etc.
                        If an error occurs, the dictionary will contain an 'error_message'
                        and a 'status' of 'error'.
    """
    logger.info(f"Initiating backtest: Strategy '{strategy_class_name}' from '{strategy_file_path}'")
    logger.info(f"Data: '{data_file_path}', Initial Cash: {initial_cash}, Commission: {commission_pct*100:.3f}%")
    if strategy_kwargs:
        logger.info(f"Strategy Parameters: {strategy_kwargs}")
    
    cerebro = bt.Cerebro()
    cerebro.broker.setcash(initial_cash)
    cerebro.broker.setcommission(commission=commission_pct)

    # --- Data Loading and Validation ---
    try:
        # Standardized CSV loading:
        # - Skip initial non-data rows (common in some data sources).
        # - Manually assign column names if header is missing or incorrect.
        # - Parse the first column as datetime index.
        df = pd.read_csv(
            data_file_path,
            skiprows=3,       # Number of initial rows to skip (adjust if data format varies)
            header=None,      # Assume no header row after skipping
            names=['Date', 'Close', 'High', 'Low', 'Open', 'Volume'], # Define expected column order
            index_col=0,      # Use the first column ('Date') as the index
            parse_dates=True  # Attempt to parse the index as datetime objects
        )
        
        # Data Cleaning and Type Conversion:
        # Ensure that OHLCV columns are numeric, coercing errors to NaN, then dropping rows with NaNs.
        numeric_cols = ['Open', 'High', 'Low', 'Close', 'Volume']
        for col in numeric_cols:
            if col in df.columns:
                df[col] = pd.to_numeric(df[col], errors='coerce')
            else:
                # Log a warning if an expected numeric column is missing
                logger.warning(f"Expected numeric column '{col}' not found in data file '{data_file_path}'.")

        df.dropna(inplace=True) # Remove rows with any NaN values after coercion

        if df.empty:
            logger.error(f"No valid data remaining in '{data_file_path}' after cleaning. Cannot run backtest.")
            return {"status": "error", "error_message": "No valid data after cleaning."}
        
        logger.info(f"Data loaded and cleaned successfully from '{data_file_path}'. Shape: {df.shape}")

    except FileNotFoundError:
        logger.error(f"Data file not found: {data_file_path}")
        # Re-raise to be caught by the main execution block or calling function
        raise
    except Exception as e:
        logger.error(f"Error processing data file {data_file_path}: {e}", exc_info=True)
        # Re-raise for broader error handling
        raise
    # --- End of Data Loading ---

    data_feed = PandasDataFeed(dataname=df)
    cerebro.adddata(data_feed)
    
    # --- Strategy Loading ---
    try:
        StrategyClass = load_strategy_class_from_file(strategy_file_path, strategy_class_name)
    except (FileNotFoundError, ImportError, AttributeError) as e:
        logger.error(f"Failed to load strategy class '{strategy_class_name}': {e}", exc_info=True)
        return {"status": "error", "error_message": f"Failed to load strategy: {e}"}

    cerebro.addstrategy(StrategyClass, **strategy_kwargs)
    
    # --- Add Analyzers ---
    # These analyzers calculate common performance metrics.
    cerebro.addanalyzer(bt.analyzers.SharpeRatio, _name='sharpe_ratio', timeframe=bt.TimeFrame.Days)
    cerebro.addanalyzer(bt.analyzers.AnnualReturn, _name='annual_return')
    cerebro.addanalyzer(bt.analyzers.DrawDown, _name='drawdown')
    cerebro.addanalyzer(bt.analyzers.TradeAnalyzer, _name='trade_analyzer')
    # TODO: Consider adding a custom analyzer for more detailed trade logging if needed.
    
    # --- Cerebro Run ---
    try:
        results = cerebro.run()
        if not results or not results[0]: # Check if Cerebro returned any strategy instances
            logger.error("Cerebro run did not return any strategy instances or results.")
            return {"status": "error", "error_message": "Cerebro run completed but returned no results."}
        strat_instance = results[0] # The first element is usually the strategy instance
        logger.info("Cerebro backtest run completed successfully.")
    except Exception as e:
        logger.error(f"Cerebro run failed during execution: {e}", exc_info=True)
        return {"status": "error", "error_message": f"Cerebro run failed: {e}"}

    # --- Metrics Extraction ---
    # Safely extract metrics, providing defaults or NaN for robustness.
    final_portfolio_value = cerebro.broker.getvalue()

    sharpe_analysis = strat_instance.analyzers.sharpe_ratio.get_analysis()
    sharpe_ratio = sharpe_analysis.get('sharperatio', float('nan')) # Use float('nan') as a clear indicator of missing data

    annual_return_analysis = strat_instance.analyzers.annual_return.get_analysis()
    # Calculate average annual return if data exists, else NaN
    avg_annual_return_pct = (sum(annual_return_analysis.values()) / len(annual_return_analysis) * 100) \
        if annual_return_analysis and len(annual_return_analysis) > 0 else float('nan')

    drawdown_analysis = strat_instance.analyzers.drawdown.get_analysis()
    max_drawdown_pct = drawdown_analysis.get('max', {}).get('drawdown', float('nan'))

    trade_analysis = strat_instance.analyzers.trade_analyzer.get_analysis()
    total_trades = trade_analysis.get('total', {}).get('total', 0)
    winning_trades = trade_analysis.get('won', {}).get('total', 0)
    losing_trades = trade_analysis.get('lost', {}).get('total', 0)
    # Calculate win rate, handling division by zero if no trades occurred.
    win_rate_pct = (winning_trades / total_trades * 100) if total_trades > 0 else 0.0
    
    metrics = {
        'status': 'completed',
        'final_portfolio_value': final_portfolio_value,
        'sharpe_ratio': sharpe_ratio if sharpe_ratio is not None else float('nan'), # Ensure None is also handled as NaN
        'average_annual_return_pct': avg_annual_return_pct,
        'max_drawdown_pct': max_drawdown_pct,
        'total_trades': total_trades,
        'winning_trades': winning_trades,
        'losing_trades': losing_trades,
        'win_rate_pct': win_rate_pct,
        'strategy_params_used': strategy_kwargs # Include parameters for traceability
    }
    logger.info(f"Backtest metrics extracted: {json.dumps(metrics, indent=2)}")

    # --- Optional Plotting ---
    # Plotting can be made conditional (e.g., if plot_strategy_behavior is available and a flag is set).
    # Example:
    # if plot_strategy_behavior and kwargs.get('plot_results', False):
    #     try:
    #         # Extract necessary trade data for plotting
    #         # trades_for_plot = extract_trades_for_plotting(strat_instance)
    #         # plot_strategy_behavior(df, trades_for_plot)
    #         logger.info("Strategy behavior plot generated.")
    #     except Exception as e:
    #         logger.error(f"Failed to generate strategy plot: {e}", exc_info=True)

    return metrics

# --- Main Execution Block ---
# This allows the script to be run directly from the command line for testing or standalone backtests.
if __name__ == '__main__':
    # Configure logging specifically for command-line execution.
    # This setup ensures that logs are directed to stdout and are formatted clearly.
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(name)s - %(module)s.%(funcName)s:L%(lineno)d - %(message)s',
        handlers=[logging.StreamHandler(sys.stdout)], # Ensure logs go to standard output
        force=True # Override any existing root logger configuration (Python 3.8+)
    )

    parser = argparse.ArgumentParser(
        description="Run a single Backtrader backtest.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter # Show default values in help
    )
    # Define command-line arguments with clear help messages.
    parser.add_argument('--strategy-file', required=True,
                        help="Path to the Python strategy file (relative to project root).")
    parser.add_argument('--data-file', required=True,
                        help="Path to the CSV data file (relative to project root).")
    parser.add_argument('--strategy-class-name', required=True,
                        help="Name of the strategy class defined within the strategy file.")
    parser.add_argument('--strategy-params', default="{}",
                        help="JSON string of parameters to pass to the strategy's constructor.")
    parser.add_argument('--initial-cash', type=float, default=100000.0,
                        help="Initial cash amount for the backtest.")
    parser.add_argument('--commission', type=float, default=0.001,
                        help="Commission percentage per trade (e.g., 0.001 for 0.1%).")
    
    args = parser.parse_args()

    try:
        # Construct absolute paths from the (potentially relative) command-line arguments.
        # PROJECT_ROOT is defined at the top of this script.
        absolute_strategy_path = (PROJECT_ROOT / args.strategy_file).resolve()
        absolute_data_path = (PROJECT_ROOT / args.data_file).resolve()

        # Validate that the constructed file paths actually exist before proceeding.
        if not absolute_strategy_path.is_file():
            logger.error(f"Strategy file does not exist or is not a file: {absolute_strategy_path}")
            # Also print to stderr for immediate visibility if logging is misconfigured.
            print(f"Error: Strategy file not found: {absolute_strategy_path}", file=sys.stderr)
            sys.exit(1) # Exit with a non-zero status code to indicate failure.
        if not absolute_data_path.is_file():
            logger.error(f"Data file does not exist or is not a file: {absolute_data_path}")
            print(f"Error: Data file not found: {absolute_data_path}", file=sys.stderr)
            sys.exit(1)

        # Attempt to parse the strategy parameters from the JSON string.
        try:
            params = json.loads(args.strategy_params)
            if not isinstance(params, dict): # Ensure it's a dictionary
                raise json.JSONDecodeError("Strategy params must be a JSON object.", args.strategy_params, 0)
        except json.JSONDecodeError as e:
            logger.error(f"Invalid JSON format for --strategy-params: '{args.strategy_params}'. Error: {e}")
            print(f"Error: Invalid JSON for --strategy-params: {e}", file=sys.stderr)
            sys.exit(1)

        logger.info(f"Starting backtest via command line: Strategy File='{absolute_strategy_path}', Data File='{absolute_data_path}'")
        
        # Call the core backtesting function with the parsed arguments.
        metrics_output = run_backtest(
            strategy_file_path=str(absolute_strategy_path),
            data_file_path=str(absolute_data_path),
            strategy_class_name=args.strategy_class_name,
            initial_cash=args.initial_cash,
            commission_pct=args.commission,
            **params  # Unpack the parsed strategy parameters as keyword arguments
        )
        
        # Output the resulting metrics as a JSON string to standard output.
        # Using indent=4 for pretty printing, making it easier to read.
        print(json.dumps(metrics_output, indent=4))
        
    except FileNotFoundError as e:
        # Specifically handle FileNotFoundError that might be raised from run_backtest (e.g., during data loading)
        logger.error(f"File not found during backtest setup: {e}", exc_info=True)
        print(json.dumps({"status": "error", "error_message": f"File not found: {e}", "error_type": "FileNotFoundError"}), file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        # Catch-all for any other unexpected exceptions during the process.
        logger.error(f"An unexpected error occurred during command-line backtest execution: {e}", exc_info=True)
        # Output a JSON error message to standard error.
        print(json.dumps({"status": "error", "error_message": str(e), "error_type": type(e).__name__}), file=sys.stderr)
        sys.exit(1)
